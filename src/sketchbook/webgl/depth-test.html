{% extends "_sketch.html" %}

{% set sketch_libs %}
<script type="text/javascript" src="/sketchbook/_lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="/sketchbook/_lib/webgl.js"></script>
{% endset %}

{% set sketch_source %}
<script type="x-shader/x-vertex" id="hello-vertex-shader">
  attribute vec3 a_position;

  uniform mat4 uMVMatrix;
  uniform mat4 uCamMatrix;
  uniform mat4 uPMatrix;

  void main() {
     gl_Position = uPMatrix * uCamMatrix * uMVMatrix * vec4(a_position, 1);
  }
</script>
<script type="x-shader/x-fragment" id="hello-fragment-shader">
  uniform lowp vec4 uColor;

  void main() {
    // gl_FragColor = uColor;
    gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
  }
</script>
{% endset %}

{% set sketch_source_js %}

var gl
var program

var positionLocation
var colorLocation

var pMatrixUniform
var camMatrixUniform
var mvMatrixUniform
var colorUniform

var mvMatrixUniform

// var eyeVec3 = vec3.fromValues(-10, 10, 0)
var eyeVec3 = vec3.fromValues(0, 0, 10)
var eyeVec3 = vec3.fromValues(0, 1, 2)
var eyeRotMatrix

var pMatrix
var camMatrix
var mvMatrix

var vertexDim = 3
var rectVertices = [
   0.0, 0.0, 0.0,
   0.0, 1.0, 0.0,
   1.0, 0.0, 0.0,
   1.0, 0.0, 0.0,
   0.0, 1.0, 0.0,
   1.0, 1.0, 0.0,
]
var numVertices = rectVertices.length / vertexDim
var vertexBuffer

var rotation = 0.0

function drawRect(x, y, z, w, h) {
  // set up model
  mat4.identity(mvMatrix)

  mat4.translate(mvMatrix, mvMatrix, [x, y, z])
  mat4.scale(mvMatrix, mvMatrix, [w, h, 0])

  gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix);
  gl.uniformMatrix4fv(camMatrixUniform, false, camMatrix);
  gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix);

  gl.uniform4fv(colorUniform, [
    Math.random(),
    Math.random(),
    Math.random(),
    1.0
  ]);

  // draw
  gl.drawArrays(gl.TRIANGLES, 0, numVertices);
}

function render() {

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

  mat4.identity(pMatrix)
  mat4.perspective(
    pMatrix, 45,
    gl.drawingBufferWidth / gl.drawingBufferHeight,
    1, -1000)

  // var orthoDim = 1
  // mat4.ortho(pMatrix, -orthoDim, orthoDim, -orthoDim, orthoDim, 0, 10)

  mat4.identity(camMatrix)
  mat4.lookAt(camMatrix,
    eyeVec3,
    [0, 0, 0],
    [0, 1, 0])

  // vec3.transformMat4(eyeVec3, eyeVec3, eyeRotMatrix)

  // drawRect(0, 0, 0, 1.0, 1.0)

  var dim = 5
  for (var i = 0; i < 10; i++) {
    drawRect(
      -0.5, -0.5, i * -1.0,
      1.0, 1.0)
  }

  rotation = (rotation + 0.05)
  // setTimeout(render, 1000/60)
}

function start() {
    gl = createContext(500, 500)

    // setup a GLSL program
    program = createProgramFromScripts(gl, [
      "hello-vertex-shader",
      "hello-fragment-shader"
    ]);
    gl.useProgram(program);

    gl.clearColor(0.0, 0.0, 0.0, 1.0)

    gl.enable(gl.DEPTH_TEST)
    gl.depthFunc(gl.LESS)
    // gl.depthFunc(gl.ALWAYS)

    // look up where the vertex and color data needs to go.
    positionLocation = gl.getAttribLocation(program, "a_position");

    // shader uniforms
    pMatrixUniform = gl.getUniformLocation(program, "uPMatrix");
    camMatrixUniform = gl.getUniformLocation(program, "uCamMatrix");
    mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
    colorUniform = gl.getUniformLocation(program, "uColor");

    eyeRotMatrix = mat4.create()
    mat4.identity(eyeRotMatrix)

    pMatrix = mat4.create()
    camMatrix = mat4.create()
    mvMatrix = mat4.create()

    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rectVertices), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, vertexDim, gl.FLOAT, false, 0, 0);

    render()
  }

  start()

{% endset %}
